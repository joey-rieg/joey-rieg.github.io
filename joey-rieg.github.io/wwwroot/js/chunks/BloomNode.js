import{TSL as e,TempNode as L,NodeUpdateType as U,RendererUtils as F,QuadMesh as G,NodeMaterial as w}from"./three.webgpu.js";import{R as S,H as v,V as f,a as _}from"../main.js";e.BRDF_GGX;e.BRDF_Lambert;e.BasicPointShadowFilter;e.BasicShadowFilter;e.Break;e.Const;e.Continue;e.DFGApprox;e.D_GGX;e.Discard;e.EPSILON;e.F_Schlick;const T=e.Fn;e.INFINITY;e.If;const k=e.Loop;e.NodeAccess;e.NodeShaderStage;e.NodeType;e.NodeUpdateType;e.PCFShadowFilter;e.PCFSoftShadowFilter;e.PI;e.PI2;e.PointShadowFilter;e.Return;e.Schlick_to_F0;e.ScriptableNodeResources;e.ShaderNode;e.Stack;e.Switch;e.TBNViewMatrix;e.VSMShadowFilter;e.V_GGX_SmithCorrelated;e.Var;e.VarIntent;e.abs;e.acesFilmicToneMapping;e.acos;const j=e.add;e.addMethodChaining;e.addNodeElement;e.agxToneMapping;e.all;e.alphaT;e.and;e.anisotropy;e.anisotropyB;e.anisotropyT;e.any;e.append;e.array;e.arrayBuffer;e.asin;e.assign;e.atan;e.atan2;e.atomicAdd;e.atomicAnd;e.atomicFunc;e.atomicLoad;e.atomicMax;e.atomicMin;e.atomicOr;e.atomicStore;e.atomicSub;e.atomicXor;e.attenuationColor;e.attenuationDistance;e.attribute;e.attributeArray;e.backgroundBlurriness;e.backgroundIntensity;e.backgroundRotation;e.batch;e.bentNormalView;e.billboarding;e.bitAnd;e.bitNot;e.bitOr;e.bitXor;e.bitangentGeometry;e.bitangentLocal;e.bitangentView;e.bitangentWorld;e.bitcast;e.blendBurn;e.blendColor;e.blendDodge;e.blendOverlay;e.blendScreen;e.blur;e.bool;e.buffer;e.bufferAttribute;e.bumpMap;e.burn;e.bvec2;e.bvec3;e.bvec4;e.bypass;e.cache;e.call;e.cameraFar;e.cameraIndex;e.cameraNear;e.cameraNormalMatrix;e.cameraPosition;e.cameraProjectionMatrix;e.cameraProjectionMatrixInverse;e.cameraViewMatrix;e.cameraWorldMatrix;e.cbrt;e.cdl;e.ceil;e.checker;e.cineonToneMapping;e.clamp;e.clearcoat;e.clearcoatNormalView;e.clearcoatRoughness;e.code;e.color;e.colorSpaceToWorking;e.colorToDirection;e.compute;e.computeKernel;e.computeSkinning;e.context;e.convert;e.convertColorSpace;e.convertToTexture;e.cos;e.cross;e.cubeTexture;e.cubeTextureBase;e.cubeToUV;e.dFdx;e.dFdy;e.dashSize;e.debug;e.decrement;e.decrementBefore;e.defaultBuildStages;e.defaultShaderStages;e.defined;e.degrees;e.deltaTime;e.densityFog;e.densityFogFactor;e.depth;e.depthPass;e.determinant;e.difference;e.diffuseColor;e.directPointLight;e.directionToColor;e.directionToFaceDirection;e.dispersion;e.distance;e.div;e.dodge;e.dot;e.drawIndex;e.dynamicBufferAttribute;e.element;e.emissive;e.equal;e.equals;e.equirectUV;e.exp;e.exp2;e.expression;e.faceDirection;e.faceForward;e.faceforward;const P=e.float;e.floor;e.fog;e.fract;e.frameGroup;e.frameId;e.frontFacing;e.fwidth;e.gain;e.gapSize;e.getConstNodeType;e.getCurrentStack;e.getDirection;e.getDistanceAttenuation;e.getGeometryRoughness;e.getNormalFromDepth;e.getParallaxCorrectNormal;e.getRoughness;e.getScreenPosition;e.getShIrradianceAt;e.getShadowMaterial;e.getShadowRenderObjectFunction;e.getTextureIndex;e.getViewPosition;e.globalId;e.glsl;e.glslFn;e.grayscale;e.greaterThan;e.greaterThanEqual;e.hash;e.highpModelNormalViewMatrix;e.highpModelViewMatrix;e.hue;e.increment;e.incrementBefore;e.instance;e.instanceIndex;e.instancedArray;e.instancedBufferAttribute;e.instancedDynamicBufferAttribute;e.instancedMesh;const D=e.int;e.inverse;e.inverseSqrt;e.inversesqrt;e.invocationLocalIndex;e.invocationSubgroupIndex;e.ior;e.iridescence;e.iridescenceIOR;e.iridescenceThickness;e.ivec2;e.ivec3;e.ivec4;e.js;e.label;e.length;e.lengthSq;e.lessThan;e.lessThanEqual;e.lightPosition;e.lightProjectionUV;e.lightShadowMatrix;e.lightTargetDirection;e.lightTargetPosition;e.lightViewPosition;e.lightingContext;e.lights;e.linearDepth;e.linearToneMapping;e.localId;e.log;e.log2;e.logarithmicDepthToViewZ;const W=e.luminance;e.mat2;e.mat3;e.mat4;e.matcapUV;e.materialAO;e.materialAlphaTest;e.materialAnisotropy;e.materialAnisotropyVector;e.materialAttenuationColor;e.materialAttenuationDistance;e.materialClearcoat;e.materialClearcoatNormal;e.materialClearcoatRoughness;e.materialColor;e.materialDispersion;e.materialEmissive;e.materialEnvIntensity;e.materialEnvRotation;e.materialIOR;e.materialIridescence;e.materialIridescenceIOR;e.materialIridescenceThickness;e.materialLightMap;e.materialLineDashOffset;e.materialLineDashSize;e.materialLineGapSize;e.materialLineScale;e.materialLineWidth;e.materialMetalness;e.materialNormal;e.materialOpacity;e.materialPointSize;e.materialReference;e.materialReflectivity;e.materialRefractionRatio;e.materialRotation;e.materialRoughness;e.materialSheen;e.materialSheenRoughness;e.materialShininess;e.materialSpecular;e.materialSpecularColor;e.materialSpecularIntensity;e.materialSpecularStrength;e.materialThickness;e.materialTransmission;e.max;e.maxMipLevel;e.mediumpModelViewMatrix;e.metalness;e.min;const C=e.mix;e.mixElement;e.mod;e.modInt;e.modelDirection;e.modelNormalMatrix;e.modelPosition;e.modelRadius;e.modelScale;e.modelViewMatrix;e.modelViewPosition;e.modelViewProjection;e.modelWorldMatrix;e.modelWorldMatrixInverse;e.morphReference;e.mrt;e.mul;e.mx_aastep;e.mx_add;e.mx_atan2;e.mx_cell_noise_float;e.mx_contrast;e.mx_divide;e.mx_fractal_noise_float;e.mx_fractal_noise_vec2;e.mx_fractal_noise_vec3;e.mx_fractal_noise_vec4;e.mx_frame;e.mx_heighttonormal;e.mx_hsvtorgb;e.mx_ifequal;e.mx_ifgreater;e.mx_ifgreatereq;e.mx_invert;e.mx_modulo;e.mx_multiply;e.mx_noise_float;e.mx_noise_vec3;e.mx_noise_vec4;e.mx_place2d;e.mx_power;e.mx_ramp4;e.mx_ramplr;e.mx_ramptb;e.mx_rgbtohsv;e.mx_rotate2d;e.mx_rotate3d;e.mx_safepower;e.mx_separate;e.mx_splitlr;e.mx_splittb;e.mx_srgb_texture_to_lin_rec709;e.mx_subtract;e.mx_timer;e.mx_transform_uv;e.mx_unifiednoise2d;e.mx_unifiednoise3d;e.mx_worley_noise_float;e.mx_worley_noise_vec2;e.mx_worley_noise_vec3;e.negate;e.neutralToneMapping;e.nodeArray;e.nodeImmutable;const R=e.nodeObject;e.nodeObjectIntent;e.nodeObjects;e.nodeProxy;e.nodeProxyIntent;e.normalFlat;e.normalGeometry;e.normalLocal;e.normalMap;e.normalView;e.normalViewGeometry;e.normalWorld;e.normalWorldGeometry;e.normalize;e.not;e.notEqual;e.numWorkgroups;e.objectDirection;e.objectGroup;e.objectPosition;e.objectRadius;e.objectScale;e.objectViewPosition;e.objectWorldMatrix;e.OnObjectUpdate;e.OnMaterialUpdate;e.oneMinus;e.or;e.orthographicDepthToViewZ;e.oscSawtooth;e.oscSine;e.oscSquare;e.oscTriangle;e.output;e.outputStruct;e.overlay;e.overloadingFn;e.parabola;e.parallaxDirection;e.parallaxUV;e.parameter;e.pass;const E=e.passTexture;e.pcurve;e.perspectiveDepthToViewZ;e.pmremTexture;e.pointShadow;e.pointUV;e.pointWidth;e.positionGeometry;e.positionLocal;e.positionPrevious;e.positionView;e.positionViewDirection;e.positionWorld;e.positionWorldDirection;e.posterize;e.pow;e.pow2;e.pow3;e.pow4;e.premultiplyAlpha;e.property;e.radians;e.rand;e.range;e.rangeFog;e.rangeFogFactor;e.reciprocal;e.reference;e.referenceBuffer;e.reflect;e.reflectVector;e.reflectView;e.reflector;e.refract;e.refractVector;e.refractView;e.reinhardToneMapping;e.remap;e.remapClamp;e.renderGroup;e.renderOutput;e.rendererReference;e.rotate;e.rotateUV;e.roughness;e.round;e.rtt;e.sRGBTransferEOTF;e.sRGBTransferOETF;e.sample;e.sampler;e.samplerComparison;e.saturate;e.saturation;e.screen;e.screenCoordinate;e.screenSize;e.screenUV;e.scriptable;e.scriptableValue;e.select;e.setCurrentStack;e.setName;e.shaderStages;e.shadow;e.shadowPositionWorld;e.shapeCircle;e.sharedUniformGroup;e.sheen;e.sheenRoughness;e.shiftLeft;e.shiftRight;e.shininess;e.sign;e.sin;e.sinc;e.skinning;const q=e.smoothstep;e.smoothstepElement;e.specularColor;e.specularF90;e.spherizeUV;e.split;e.spritesheetUV;e.sqrt;e.stack;e.step;e.stepElement;e.storage;e.storageBarrier;e.storageObject;e.storageTexture;e.string;e.struct;e.sub;e.subBuild;e.subgroupIndex;e.subgroupSize;e.tan;e.tangentGeometry;e.tangentLocal;e.tangentView;e.tangentWorld;e.temp;const h=e.texture;e.texture3D;e.textureBarrier;e.textureBicubic;e.textureBicubicLevel;e.textureCubeUV;e.textureLoad;e.textureSize;e.textureStore;e.thickness;e.time;e.timerDelta;e.timerGlobal;e.timerLocal;e.toneMapping;e.toneMappingExposure;e.toonOutlinePass;e.transformDirection;e.transformNormal;e.transformNormalToView;e.transformedClearcoatNormalView;e.transformedNormalView;e.transformedNormalWorld;e.transmission;e.transpose;e.triNoise3D;e.triplanarTexture;e.triplanarTextures;e.trunc;e.uint;const x=e.uniform,M=e.uniformArray;e.uniformCubeTexture;e.uniformGroup;e.uniformTexture;e.unpremultiplyAlpha;e.userData;const H=e.uv;e.uvec2;e.uvec3;e.uvec4;e.varying;e.varyingProperty;e.vec2;e.vec3;const p=e.vec4;e.vectorComponents;e.velocity;e.vertexColor;e.vertexIndex;e.vertexStage;e.vibrance;e.viewZToLogarithmicDepth;e.viewZToOrthographicDepth;e.viewZToPerspectiveDepth;e.viewport;e.viewportCoordinate;e.viewportDepthTexture;e.viewportLinearDepth;e.viewportMipTexture;e.viewportResolution;e.viewportSafeUV;e.viewportSharedTexture;e.viewportSize;e.viewportTexture;e.viewportUV;e.wgsl;e.wgslFn;e.workgroupArray;e.workgroupBarrier;e.workgroupId;e.workingToColorSpace;e.xor;const g=new G,X=new f,Z=new f(1,0),Y=new f(0,1);let B;class K extends L{static get type(){return"BloomNode"}constructor(a,r=1,o=0,i=0){super("vec4"),this.inputNode=a,this.strength=x(r),this.radius=x(o),this.threshold=x(i),this.smoothWidth=x(.01),this._renderTargetsHorizontal=[],this._renderTargetsVertical=[],this._nMips=5,this._renderTargetBright=new S(1,1,{depthBuffer:!1,type:v}),this._renderTargetBright.texture.name="UnrealBloomPass.bright",this._renderTargetBright.texture.generateMipmaps=!1;for(let t=0;t<this._nMips;t++){const s=new S(1,1,{depthBuffer:!1,type:v});s.texture.name="UnrealBloomPass.h"+t,s.texture.generateMipmaps=!1,this._renderTargetsHorizontal.push(s);const u=new S(1,1,{depthBuffer:!1,type:v});u.texture.name="UnrealBloomPass.v"+t,u.texture.generateMipmaps=!1,this._renderTargetsVertical.push(u)}this._compositeMaterial=null,this._highPassFilterMaterial=null,this._separableBlurMaterials=[],this._textureNodeBright=h(this._renderTargetBright.texture),this._textureNodeBlur0=h(this._renderTargetsVertical[0].texture),this._textureNodeBlur1=h(this._renderTargetsVertical[1].texture),this._textureNodeBlur2=h(this._renderTargetsVertical[2].texture),this._textureNodeBlur3=h(this._renderTargetsVertical[3].texture),this._textureNodeBlur4=h(this._renderTargetsVertical[4].texture),this._textureOutput=E(this,this._renderTargetsHorizontal[0].texture),this.updateBeforeType=U.FRAME}getTextureNode(){return this._textureOutput}setSize(a,r){let o=Math.round(a/2),i=Math.round(r/2);this._renderTargetBright.setSize(o,i);for(let t=0;t<this._nMips;t++)this._renderTargetsHorizontal[t].setSize(o,i),this._renderTargetsVertical[t].setSize(o,i),this._separableBlurMaterials[t].invSize.value.set(1/o,1/i),o=Math.round(o/2),i=Math.round(i/2)}updateBefore(a){const{renderer:r}=a;B=F.resetRendererState(r,B);const o=r.getDrawingBufferSize(X);this.setSize(o.width,o.height),r.setRenderTarget(this._renderTargetBright),g.material=this._highPassFilterMaterial,g.render(r);let i=this._renderTargetBright;for(let t=0;t<this._nMips;t++)g.material=this._separableBlurMaterials[t],this._separableBlurMaterials[t].colorTexture.value=i.texture,this._separableBlurMaterials[t].direction.value=Z,r.setRenderTarget(this._renderTargetsHorizontal[t]),g.render(r),this._separableBlurMaterials[t].colorTexture.value=this._renderTargetsHorizontal[t].texture,this._separableBlurMaterials[t].direction.value=Y,r.setRenderTarget(this._renderTargetsVertical[t]),g.render(r),i=this._renderTargetsVertical[t];r.setRenderTarget(this._renderTargetsHorizontal[0]),g.material=this._compositeMaterial,g.render(r),F.restoreRendererState(r,B)}setup(a){const r=T(()=>{const n=this.inputNode,c=W(n.rgb),m=q(this.threshold,this.threshold.add(this.smoothWidth),c);return C(p(0),n,m)});this._highPassFilterMaterial=this._highPassFilterMaterial||new w,this._highPassFilterMaterial.fragmentNode=r().context(a.getSharedContext()),this._highPassFilterMaterial.name="Bloom_highPass",this._highPassFilterMaterial.needsUpdate=!0;const o=[6,10,14,18,22];for(let n=0;n<this._nMips;n++)this._separableBlurMaterials.push(this._getSeparableBlurMaterial(a,o[n]));const i=M([1,.8,.6,.4,.2]),t=M([new _(1,1,1),new _(1,1,1),new _(1,1,1),new _(1,1,1),new _(1,1,1)]),s=T(([n,c])=>{const m=P(1.2).sub(n);return C(n,m,c)}).setLayout({name:"lerpBloomFactor",type:"float",inputs:[{name:"factor",type:"float"},{name:"radius",type:"float"}]}),u=T(()=>{const n=s(i.element(0),this.radius).mul(p(t.element(0),1)).mul(this._textureNodeBlur0),c=s(i.element(1),this.radius).mul(p(t.element(1),1)).mul(this._textureNodeBlur1),m=s(i.element(2),this.radius).mul(p(t.element(2),1)).mul(this._textureNodeBlur2),b=s(i.element(3),this.radius).mul(p(t.element(3),1)).mul(this._textureNodeBlur3),d=s(i.element(4),this.radius).mul(p(t.element(4),1)).mul(this._textureNodeBlur4);return n.add(c).add(m).add(b).add(d).mul(this.strength)});return this._compositeMaterial=this._compositeMaterial||new w,this._compositeMaterial.fragmentNode=u().context(a.getSharedContext()),this._compositeMaterial.name="Bloom_comp",this._compositeMaterial.needsUpdate=!0,this._textureOutput}dispose(){for(let a=0;a<this._renderTargetsHorizontal.length;a++)this._renderTargetsHorizontal[a].dispose();for(let a=0;a<this._renderTargetsVertical.length;a++)this._renderTargetsVertical[a].dispose();this._renderTargetBright.dispose()}_getSeparableBlurMaterial(a,r){const o=[],i=r/3;for(let l=0;l<r;l++)o.push(.39894*Math.exp(-.5*l*l/(i*i))/i);const t=h(null),s=M(o),u=x(new f),n=x(new f(.5,.5)),c=H(),m=l=>t.sample(l),b=T(()=>{const l=m(c).rgb.mul(s.element(0)).toVar();return k({start:D(1),end:D(r),type:"int",condition:"<"},({i:V})=>{const I=P(V),z=s.element(V),N=n.mul(u).mul(I),A=m(c.add(N)).rgb,O=m(c.sub(N)).rgb;l.addAssign(j(A,O).mul(z))}),p(l,1)}),d=new w;return d.fragmentNode=b().context(a.getSharedContext()),d.name="Bloom_separable",d.needsUpdate=!0,d.colorTexture=t,d.direction=n,d.invSize=u,d}}const $=(y,a,r,o)=>R(new K(R(y),a,r,o));export{$ as bloom,K as default};
